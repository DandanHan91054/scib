import pathlib

#configfile: "config.yaml"

""" General idea:
+ multiple data scenarios that need to go through the same process
    + integration on all methods defined with following settings
        + scaled/unscaled
        + HVG-selected/full-feature
    + metrics on all integrated outputs and settings
    + cell cycle variance and other analysis on integrated output
+ input files need to follow a specific structure
    + use symlinks to avoid copying the data
    + 1 folder per data scenario, must contain:
        + unintegrated, preprocessed file
        + folder for integrated output
        + folder for metrics output
        + folder for cell cycle variance and other analysis output
    + for each of these folders, wildcards of scaled/non-scaled, HVG/full need to be available (easiest: subfolders)
+ ideally, all files should be under a ROOT directory following the above folder structure
+ levels
     1. data scenario
     + method to output format mapping
     + scaled/unscaled
     + HVG/full feature
     + data type
"""

## variables and function definition for input files
ROOT = config["ROOT"]
DATA_SCENARIOS = config["DATA_SCENARIOS"]
SCALING = ['scaled', 'unscaled']
FEATURE_SELECTION = ['hvg', 'full_feature']

def join_path(*args):
    path = pathlib.Path(args[0])
    for d in args[1:]:
        path = path / d
    return str(path)

metric_output = {
   "final"    : join_path(ROOT, "metrics.csv"),
   "by_method": join_path(ROOT, "{{scenario}}", "metrics", "{{scaling}}", "{{hvg}}", 
                          "{method}_{o_type}.csv"),
   "single"   : join_path(ROOT, "{scenario}", "metrics", "{scaling}", "{hvg}", "{method}_{o_type}.csv")
}

integration_output = {
   "single"     : join_path(ROOT, "{scenario}", "integration", "{scaling}", "{hvg}", "{method}.h5ad"),
   "final"      : join_path(ROOT, "integration.done")
}


def get_from_scenario(scenario, key="file"):
    return DATA_SCENARIOS[scenario][key]

def get_all_metrics_files():
    all_files = []
    METHODS = config["METHODS"]
    for method, output_types in METHODS.items():
        file_pattern = metric_output["by_method"]
        for aggr_method in expand(file_pattern, method=method, o_type=output_types):
            f = expand(aggr_method, scenario=DATA_SCENARIOS, scaling=SCALING, hvg=FEATURE_SELECTION)
            all_files.extend(f)
    return all_files

## RULES
rule all:
 input: 
     # integration_output["final"],
     metric_output["final"]

## INTEGRATION
# TODO: run integration using integration script
# rule integration:
#     output: touch(join_path(ROOT, "integration.done"))

## METRICS
rule metrics:
    input: get_all_metrics_files()
    output: metric_output["final"]
    shell: "python merge.py -i {input} -o {output} --root"

rule metrics_single:
    input:
        u = lambda wildcards: get_from_scenario(wildcards.scenario, key="file"),
        i = integration_output["single"]
    output: metric_output["single"]
    params:
        batch_key = lambda wildcards: get_from_scenario(wildcards.scenario, key="batch_key"),
        label_key = lambda wildcards: get_from_scenario(wildcards.scenario, key="label_key"),
        organism  = lambda wildcards: get_from_scenario(wildcards.scenario, key="organism"),
        assay     = lambda wildcards: get_from_scenario(wildcards.scenario, key="assay"),
    shell:
        """
        OUT_DIR=$(dirname {output})
        python metrics.py -u {input.u} -i {input.i} -o $OUT_DIR \
        -b {params.batch_key} -l {params.label_key} --type {wildcards.o_type} \
        --organism {params.organism} --assay {params.assay} -v
        """

## Cell Cycle Variation
# rule cc_variation: